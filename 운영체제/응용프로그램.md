### 응용프로그램과 하드웨어 간의 통신 과정

EX A라는 응용프로그램이 프린터를 사용하려할떄 의 전과정
1. 응용 프로그램의 요청: A라는 응용프로그램이 운영체제에 프린트 작업을 요청합니다. 이를 위해 응용 프로그램은 시스템 호출(system call)을 사용해 운영체제에게 이 작업을 수행하도록 요청합니다.
2. 운영체제의 커널로의 요청 전달: 시스템 호출이 받아들여지면, 요청은 운영체제의 커널로 전달됩니다. 커널은 시스템의 하드웨어 자원을 관리하는 중심적인 부분입니다.
3. 커널에서 프린터 드라이버로(디바이스 드라이버)의 요청 전달: 커널은 이 요청을 해당 특정 프린터 드라이버로 전달합니다. 드라이버는 하드웨어와 소프트웨어 사이의 통신을 담당하는 소프트웨어입니다.
4. 드라이버에서 프린터 컨트롤러(디바이스 컨트롤러)로의 요청 전달: 프린터 드라이버는 이 요청을 프린터의 컨트롤러로 전달합니다. 컨트롤러는 하드웨어의 동작을 제어하는 역할을 합니다.
5. 프린터 컨트롤러에서 프린터 하드웨어로의 요청 전달: 프린터 컨트롤러는 이 요청을 프린터 하드웨어로 전달합니다. 프린터 하드웨어는 이 요청을 받아들여 프린트 작업을 수행합니다.
6. 프린터 하드웨어에서 프린터 버퍼(로컬 버퍼)로의 요청 전달: 프린터 하드웨어는 프린터 버퍼로 데이터를 전달합니다. 버퍼는 프린터가 인쇄 작업을 수행하는 동안 데이터를 임시로 저장하는 곳입니다.</br>
이떄 요청전달은 디바이스 컨트롤러에서 담당합니다.

이 과정에서 각 단계는 이전 단계의 요청을 받아 그 요청을 다음 단계가 이해할 수 있는 형태로 변환하는 역할을 합니다. 
이렇게 하여 운영체제와 응용 프로그램, 하드웨어 간의 복잡한 상호 작용이 가능해집니다.

기본적으로 버퍼의 목적은 하드웨어의 작동 속도와 컴퓨터의 작동 속도 사이의 차이를 극복하고, 데이터 전달 과정을 안정화하는 데 도움을 줍니다.
여기서 5. 에서 컨트롤러 => 버퍼 => 하드웨어 인지 아니면 바로 컨트롤러 =>  하드웨어인지의 방식인지는
하드웨어의 설계, 용도, 그리고 하드웨어의 데이터 처리 능력에 따라 결정됩니다.

프린터를 예를 들면, 대용량의 프린트 작업을 처리하는 사무용 프린터는 데이터를 효율적으로 관리하기 위해 내부 버퍼를 사용할 가능성이 높습니다. 
반면, 작은 휴대용 프린터나 실시간 출력이 중요한 환경에서 사용되는 프린터는 내부 버퍼의 사용을 최소화하고 
빠른 데이터 전송을 위해 컨트롤러를 직접 하드웨어로 연결하는 방식을 사용할 수 있습니다.


## 로컬 버퍼란?
각 장치마다 제어하기 위해 설치된 장치 컨트롤러에 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
버퍼의 목적은 하드웨어의 작동 속도와 컴퓨터의 작동 속도 사이의 차이를 극복하고, 데이터 전달 과정을 안정화하는 데 도움을 줍니다.

- 속도 차이 극복: 컴퓨터의 CPU는 일반적으로 연결된 주변 장치보다 빠른 속도로 데이터를 처리할 수 있습니다.
예를 들어, 프린터와 같은 외부 장치는 상대적으로 느린 처리 속도를 가질 수 있습니다. 
버퍼는 이러한 속도 차이를 완화하기 위해 사용됩니다. 
데이터는 먼저 버퍼에 저장되고, 장치가 준비되었을 때 해당 장치로 전송됩니다.

- 데이터 전송 안정화: 버퍼는 데이터의 연속적이고 안정적인 전송을 보장하는 역할을 합니다. 
장치 컨트롤러는 버퍼에 저장된 데이터를 관리하여, 장치가 데이터를 일관되고 안정적인 속도로 처리할 수 있도록 합니다.

- 효율성 향상: 버퍼는 시스템의 전반적인 효율성을 향상시킵니다. 
데이터가 버퍼에 저장됨으로써, CPU는 다른 작업을 계속 진행할 수 있으며,
장치는 자체 속도에 맞추어 데이터를 처리할 수 있습니다. 이는 시스템 자원의 효율적인 사용을 가능하게 합니다.

## 디바이스 컨트롤러란?
디바이스 컨트롤러(Device Controller): 이는 하드웨어의 한 부분으로, 특정 하드웨어 장치를 제어하는 역할을 합니다.
   예를 들어, 디스크 드라이브 컨트롤러는 디스크의 읽기/쓰기를 제어하고, 그래픽 카드 컨트롤러는 화면 출력을 제어하는 등의 역할을 합니다.


### 드라이버란?
- 드라이버(Device Driver): Device Driver 또는 장치 드라이버는
컴퓨터의 운영체제가 특정 하드웨어 장치를 제어할 수 있게 해주는 소프트웨어입니다.
따라서 드라이버는 운영체제와 디바이스 컨트롤러 사이에서 중개자 역할을 하며, 
운영체제의 명령을 디바이스 컨트롤러가 이해할 수 있는 형태로 변환하고, 그 반대도 수행합니다.

-소프트웨어 드라이버
특정 유형의 소프트웨어 기능을 구현하기 위해 사용되는 드라이버를 지칭합니다. 
이러한 드라이버는 가상 하드웨어, 네트워크 기능(VPN), 보안 솔루션 등을 운영체제 내에서 실행하기 위해 필요하며, 
일반적으로 운영체제의 커널 모드에서 동작합니다.

소프트웨어 드라이버는 하드웨어 장치를 직접 제어하는 것이 아니라, 
운영체제의 깊은 수준에서 특정 소프트웨어 기능을 실행하거나 시스템 리소스를 관리하기 위해 사용됩니다. 
이들은 일반적으로 커널 모드에서 동작하기에 높은 권한(Ring 0)을 요구하며, 시스템의 안정성과 보안에 직접적인 영향을 미칠 수 있습니다.

### 시스템 콜이란?

대다수의 운영체제들은 커널 모드(Kernel Mode)와 사용자 모드(User Mode)가 구분되어 있으며, 커널 모드는 Ring0에 사용자 모드는 Ring3에 속한다. (Ring 1~2는 장치 드라이버 전용이다)

커널 모드는 커널 및 커널에 붙는 드라이버들이 작동되는 영역으로 모든 컴퓨터 리소스에 접근할 수 있다.
그리고 하나의 가상 메모리 영역만을 공유하여 커널과 드라이버가 서로 접근할 수 있다. 다만 그 만큼 불안정해서 만일 커널이나 드라이버 중 하나라도 오류가 일어나면 치명적이다.

사용자 모드는 일반 프로그램들이 작동되는 영역으로 컴퓨터 리소스에 제한적으로 접근이 가능하고 프로그램들은 프로세스로 작동한다.
프로세스의 가상 메모리 영역은 다른 프로세스가 볼 수 없으므로 다른 프로세스와 정보를 주고받기 위해서는 프로세스간 통신을 이용해야 한다.
대신 프로세스들은 각각 독립적으로 작동하기 때문에 한 프로세스에서 오류가 발생해도 그 프로세스만 종료될 뿐이지 운영체제와 다른 프로세스에 영향을 미치지 않아 안정성이 높다.

일반적인 프로그램들은 사용자 모드에서 실행되므로 커널 모드에 대한 직접적인 접근이 불가능하다.
하지만 커널에 접근할 수 없으면 사용자 모드의 프로세스들이 파일을 쓰거나 불러올 수 없고 그래픽 처리와 같은 거의 모든 작업을 할 수 없다.
따라서 커널에 요청하여 커널 모드에서 처리하고 그 결과를 사용자 모드의 프로그램에게 전달하는 것이 바로 시스템 콜이다.

시스템 콜은 프로그램의 거의 모든 코드의 실행에서 발생하며 파일 생성이나 쓰기 또는 읽기, 키보드 입력, 그래픽 출력, 스레드 생성 및 제어 같은 것도 시스템 콜을 통해 커널에 요청하여 커널 모드에서 처리한다.
예로 Windows API 중 유저레벨 API중 하나인 CreateFile()을 실행시키면 내부적으로 Private API인 NtCreateFile()가 실행되는데 이 함수는
결과적으로 커널 모드의 IoCreateFile() 함수가 실행된다.


### 특권 레밸이란?

이 개념은 CPU가 다양한 권한 수준을 가질 수 있음을 나타냅니다.
특권 레벨은 일반적으로 운영체제의 커널(가장 높은 권한)과 사용자 모드(가장 낮은 권한)를 구분하는 데 사용됩니다.
다른 CPU 아키텍처에서는 이러한 레벨이 다른 방식으로 구현될 수 있습니다.

- 부분의 모던 CPU 아키텍처, 특히 인텔 x86 아키텍처의 경우
CPU의 기능중 하나인 특권레밸로서 Ring 시스템을 사용한다.
Ring는 '보호 링'이라고 하며, CPU의 기능이다. 기본적으로 운영체제는 컴퓨터의 모든 값을 읽고 쓸 수 있다.
하지만 운영체제에서 돌아가는 프로세스도 운영체제와 똑같이 할 수 있게 하면, 안정성 및 보안성의 문제가 뒤따를 수 밖에 없기 때문에 운영체제는 CPU의 기능인 보호 링을 사용하여,
커널 모드와 사용자 모드를 나누게 된다. 거의 모든 운영체제들은 커널 모드는 Ring0에, 사용자 모드는 Ring3에 두는 것이 일반적이며, Ring1~2는 사용하지 않는다.
(Ring 1과 Ring 2는 장치 드라이버를 위해 있지만 윈도우나 리눅스에서는 딱히 사용하지 않는다. )

- ARM 아키텍처의 PL
 ARM CPU에서는 특권레벨로서 PL(ARMv7까지, Privilege Level)/EL(ARMv8 이후, Execution Level)라는 개념이 존재한다.
x86 CPU와 다르게 레벨이 높을수록 권한이 많아지고 낮을수록 권한이 작아진다.
PL0/EL0는 일반적인 앱, PL1/EL1는 커널, PL2/EL2는 하이퍼바이저, PL3/EL3는 보안 펌웨어에 해당한다.

ARM의 이러한 다중 레벨 구조는 시스템의 다양한 부분에 대한 세분화된 권한 관리를 가능하게 하여, 
보안과 효율성을 높이는 데 중요한 역할을 합니다. 
특히 가상화와 보안 측면에서 중요한 개선을 제공합니다.
