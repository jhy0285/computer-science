# 이분 탐색을 구현시 어려움들

저는 막상 이분탐색이라는 개념은 이해해도 이거를 실제로 구현할떄, 

탐색시 반복문의 종결조건을 어떻게 해야할지(left==right하면되는지 left나 right중 하나가 mid와 일치할떄면 되는지 등등)

left=mid+1, right=mid-1로 무조건 해야되는지 이런 것들이 헷갈렸습니다.

그렇게 헷갈려서 잘못 구현했을경우 무한 루프가 돌아가는 형상도 종종 있었습니다.

이 장에서는 검색을 통해 알게된 이분 탐색을 헷갈리지 않게 구현하는 방법을 정리해 보도록 하겠습니다.

---
## 이분 탐색의 아이디어

이분 탐색의 기본은 구하고자 하는 1개의 파라미터를 포함하고있는 양 끝의 경계를 left, right로 적절히 잡아주고,
그 경계의 가운데를 mid로 설정합니다. 

그 후에 
1. mid를 통해 구간을 절반으로 나눕니다(이분화).
2. 파라미터가 이분된 두 구간중 어디있는지 검사합니다
3. 파라미터가 포함된 구간의 양끝과 그 가운데를 다시 left, right, mid로 설정합니다.
4. 1~3의 과정을 반복합니다.

이때 계속 반복되다 보면 마지막에는 반드시 left의 다음 칸은 right(즉, left + 1 == right)이며 Check(left) != Check(right) 가 성립합니다.

이떄 Check(x)는 결정 문제의 parameter가 x일 때 결정 문제의 답을 의미합니다.

즉 Check(left)가 결정 문제에 답으로서 True라면, Check(right)는 False여야 하고,

Check(right)가 False라면 Check(left)는 True여야 합니다.

이 개념을 바탕으로 분기 체크나 반복문 조건을 설정하면 될거 같습니다.

---

## 헷갈리지 않는 구현 방법

1. Check(left) != Check(right)가 되도록 left, right의 초기값을 잘 설정해줍니다.
2. 반복문 조건으로 left + 1 < right인 동안 mid = (left + right) /2 로 설정합니다.
3. Check(left) == Check(mid)라면 left = mid를, Check(right) == Check(mid)라면 right = mid를 해줍니다.

이렇게 구현 하면 됩니다... 라고 하면 뭔소린지 직감적으로 오지 않으시죠? ㅎㅎ

예시를 들어서 차근차근 해보도록 합시다.

### 1.  Check(left) != Check(right)가 되도록 left, right의 초기값을 잘 설정해줍니다.

이거는 당연히 이렇게 해줘야합니다. 

왜냐하면 양끝의 결정문제에 대한 답이 달라야 반드시 그사이에 답이 바뀌기 시작하는 경계점인
파라미터가 존재한다고 보장할 수 있기 떄문입니다.

즉 정렬되어있다는 가정하에, 왼쪽 끝에 답이 False이고 오른쪽 끝에 답이 True라면</br>
그사이에 반드시 False => True로 바뀌기 시작하는 최초의 True가 True중에 제일 왼쪽에  반드시 존재하겠죠?

### 2. left + 1 < right인 동안 mid = (left + right) /2 로 설정합니다.

탐색을 반복해서 돌릴떄, left + 1 < right인 조건으로 돌리면 됩니다. 

앞에서 설명했듯이 이분탐색의 마지막에는 반드시 양 끝 경계인 left, right가 1의 차이값을 가집니다.

따라서 그직전 까지인 left + 1 < right까지 반복문을 돌립니다.

### 3. Check(left) == Check(right)라면 left = mid를, Check(right) == Check(mid)라면 right = mid를 해줍니다.

이 또한 1.의 조건인  Check(left) != Check(right) 유지되면서 구간을 반으로 줄여야하기떄문에  left와 right 양 끝 값중  mid와 결정문제에 대한 답이
같은 값에다가 mid가 대입되야 합니다.


1, 2, 3 조건을 만족시키면서 탐색을 돌리면 
최종적으로는 반드시 
- left +1= right 이고
- left와 right의 결정문제에 대한 답이 다름

상황이 되겠죠?

이떄 우리가 원하는 값이 F -> T 로 간다고 했을떄 F의 최대값인지, T의 최소값인지에 따라 left(F중 최대)와 right(T중 최소)를 정답으로
채택하면 되는 겁니다.

실제 문제로서 예시를 들어보죠


---

## 문제
[프로그래머스 입국심사 문제](https://school.programmers.co.kr/learn/courses/30/lessons/43238)

### 문제설명

n명이 입국심사를 받으려고 줄을 서서 기다리고 있습니다. 모든 입국심사대에서는 심사관이 한 사람을 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 입국심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빠른 심사대가 비어 있다면 기다리지 않고 빠른 심사대로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사대는 총 n개가 있으며, 각 심사대에서 한 사람을 심사하는데 걸리는 시간이 times[] 배열로 주어집니다. 모든 사람이 심사를 받는데 걸리는 시간의 최소값을 return 하는 solution 함수를 작성해주세요.

### 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

### 입출력 예

| n   | times   | return |
| --- | ------- | ------ |
| 6   | [7, 10] | 28     |

### 입출력 예 설명

가장 첫 번째 사람은 빠른 심사대로 갑니다.

7분이 지나면, 빠른 심사대가 비어 3번째 사람이 심사를 받습니다.

10분이 지나면, 느린 심사대가 비어 4번째 사람이 심사를 받습니다.

14분이 지나면, 빠른 심사대가 비어 5번째 사람이 심사를 받습니다.

20분이 지나면, 느린 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분 더 기다려서 빠른 심사대에서 심사를 받는 경우 모든 사람이 심사를 받는데 걸리는 시간이 28분으로 최소가 됩니다.


---

## 풀이
```python
def solution(n, times):
    
#결정문제부터 정의한다.
# 보통 어려운 이분탐색은 결정문제를 어떻게 설정할지가 난해한 경우가 많습니다.
#결정문제 : "경계사이에 있는 임의의 수 x에대해서 times의 각 원소로 나눴을때에, 몫들의 합이 n보다 같거나 큰가?"
# 위에 문장이 결정문제 라고 할수있다.
#이제 결정문제를 정의했으니, 양끝값을 결정문제에 대해 서로다른 답을 하도록 설정해야한다.

#모든 예시는 주어진 조건인 
#| n   | times   | return |
#| --- | ------- | ------ |
#| 6   | [7, 10] | 28     |
#을 사용하겠다.

    #left경우 0//7, 0//10모두 0이므로 n=6보다 작으므로 결정문제의 답이 False이다 
    left=0
    
    #right 경우 n*min(times)로 설정하였다. 
    #이 경우는 최악의 경우로서, 기다리는 사람들이 분산되지 않고 무조건 제일 오래걸리는
    #심사관만을 대기하는 상황이므로 반드시 결정문제의 답이 True이다.
    #실제로 계산해봐도 60//7=8 , 60//10=6 이므로 8+6=14>n=6 이므로 답이 True이다.
    # n*min(times)으로 설정해도 상관없다. 이또한 사람들이 분산되지 않고 한 심사관만을 대기할 경우의
    #True가 되는 최소값이면서, 한명이라도 분산될경우에는 그사이에 반드시 True라는 답을 가지는 최소값이 
    #존재하기 때문이다. 실제로 범위가 max보다 적으므로 필자는 min을 채택하였다.
    right=n*min(times)
    
    
    #중간값 변수 선언
    mid=0
    
    #결정문제를 위한 초기 숫자 선언
    answer=9999999999
    
    #정렬되어야 이분탐색을 할 수 있으므로 정렬
    times.sort()
    
    # 반복문 조건은 left+1 < right 로 둔다.
    while left+1 < right:
        
        # mid는  mid=(left+right)//2로 둔다.
        mid=(left+right)//2
        
        # 결정문제를 위한 변수 선언
        total=0
        
        #mid의 결정문제의 답을 도출하는 로직
        for time in times:
            total+=mid//time
            
            
        # total이 n보다 같거나 크다=>mid의 답이 True이다
        # => right와 답이 같다 => right=mid로 둔다.
        if total>=n:
            right=mid
            
            
        # total이 n보다 작다=>mid의 답이 False이다
        # => left와 답이 같다 => left=mid로 둔다.
        else:
            left=mid
            
            
    #반복문이 끝난다는건 left+1=right인상태이고
    # left와 right의 답이 다른상태라는 뜻이다.
    #우리가 구하는건 결정문제의 대답이 True인것들중에 최솟값 이므로
    #정답은 right가 되야한다.
    answer=right
            
        
   
    return answer
```